<?xml version="1.0" encoding="utf-8"?>
<!--
     ////////////////////////////////////////////////////////////////////////////////
     //
     // Copyright (c) 2010-2011 ESRI
     //
     // All rights reserved under the copyright laws of the United States.
     // You may freely redistribute and use this software, with or
     // without modification, provided you include the original copyright
     // and use restrictions.  See use restrictions in the file:
     // <install location>/License.txt
     //
     ////////////////////////////////////////////////////////////////////////////////
-->
<s:SkinnableContainer xmlns:fx="http://ns.adobe.com/mxml/2009"
                      xmlns:s="library://ns.adobe.com/flex/spark"
                      xmlns:mx="library://ns.adobe.com/flex/mx"
                      width="100%" height="100%"
                      creationComplete="init()"
                      skinClass="com.esri.viewer.skins.MapManagerSkin">

    <fx:Script>
        <![CDATA[
			import com.esri.ags.Graphic;
			import com.esri.ags.Map;
			import com.esri.ags.SpatialReference;
			import com.esri.ags.events.DrawEvent;
			import com.esri.ags.events.MapEvent;
			import com.esri.ags.geometry.Extent;
			import com.esri.ags.geometry.MapPoint;
			import com.esri.ags.layers.ArcGISDynamicMapServiceLayer;
			import com.esri.ags.layers.ArcGISImageServiceLayer;
			import com.esri.ags.layers.ArcGISTiledMapServiceLayer;
			import com.esri.ags.layers.ArcIMSMapServiceLayer;
			import com.esri.ags.layers.FeatureLayer;
			import com.esri.ags.layers.Layer;
			import com.esri.ags.layers.OpenStreetMapLayer;
			import com.esri.ags.layers.TiledMapServiceLayer;
			import com.esri.ags.layers.WMSLayer;
			import com.esri.ags.layers.supportClasses.LayerInfoWindowRenderer;
			import com.esri.ags.layers.supportClasses.StaticLayer_m_esriLogo;
			import com.esri.ags.symbols.SimpleFillSymbol;
			import com.esri.ags.symbols.SimpleLineSymbol;
			import com.esri.ags.symbols.SimpleMarkerSymbol;
			import com.esri.ags.symbols.Symbol;
			import com.esri.ags.symbols.TextSymbol;
			import com.esri.ags.tools.DrawTool;
			import com.esri.ags.tools.NavigationTool;
			import com.esri.ags.virtualearth.VETiledLayer;
			import com.esri.ags.webmap.PopUpRenderer;
			import com.esri.ags.webmap.supportClasses.PopUpFieldFormat;
			import com.esri.ags.webmap.supportClasses.PopUpFieldInfo;
			import com.esri.ags.webmap.supportClasses.PopUpInfo;
			import com.esri.ags.webmap.supportClasses.PopUpMediaInfo;
			import com.esri.viewer.AppEvent;
			import com.esri.viewer.ConfigData;
			import com.esri.viewer.CustomTiledLayer;
			import com.esri.viewer.GoogleAerial;
			import com.esri.viewer.GoogleAnnotation;
			import com.esri.viewer.GoogleMapLayer;
			import com.esri.viewer.GoogleTiledMapServiceLayer;
			import com.esri.viewer.IBaseWidget;
			import com.esri.viewer.IInfowindowTemplate;
			import com.esri.viewer.ViewerContainer;
			import com.esri.viewer.components.InfoPopup;
			
			import mx.collections.ArrayCollection;
			import mx.collections.ArrayList;
			import mx.containers.Canvas;
			import mx.controls.Alert;
			import mx.events.CloseEvent;
			import mx.events.FlexEvent;
			import mx.managers.CursorManagerPriority;
			import mx.rpc.AsyncResponder;
			import mx.rpc.AsyncToken;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import mx.rpc.http.HTTPService;
			import mx.utils.StringUtil;
			
			import spark.components.Group;

            [Embed(source="assets/images/cross_cursor.png")]
            private var _crossCursor:Class;
            private var _cursorID:int = -1;

            /* skin section */
            [SkinPart(required="false")]
            public var managerView:Group;

            [SkinPart(required="false")]
            public var map:Map;

            [Bindable]
            public var mapLeft:Number = 0;

            [Bindable]
            public var mapRight:Number = 0;

            [Bindable]
            public var mapTop:Number = 0;

            [Bindable]
            public var mapBottom:Number = 0;

            [SkinState("decorated")]
            [SkinState("resized")]
            [SinkState("normal")]

            private var configData:ConfigData;

            private var defaultstatus:String;

            private var infoPopup:InfoPopup;

            private var navTool:NavigationTool;

            private var navigationTool:String;

            private var navigationStatus:String;

            private var drawTool:DrawTool;

            private var drawEndFunction:Function;

            private var fullExtent:Extent;

            private var _mapManagerState:String = "resized";

            private var optLayerTable:Array = [];

            private var osmCopyrightManager:OpenStreetMapCopyrightManager;

            private function init():void
            {
                osmCopyrightManager = new OpenStreetMapCopyrightManager(map);

                ViewerContainer.addEventListener(AppEvent.CONFIG_LOADED, config);
                ViewerContainer.addEventListener(AppEvent.SET_MAP_NAVIGATION, changeNavigationbyMenu);
                ViewerContainer.addEventListener(AppEvent.BASEMAP_SWITCH, basemapMenuClicked);
                ViewerContainer.addEventListener(AppEvent.SET_MAP_ACTION, enableMapAction);
                ViewerContainer.addEventListener(AppEvent.SHOW_INFOWINDOW, widgetShowInfo);
                ViewerContainer.addEventListener(AppEvent.MAP_RESIZE, resizeMap);
                ViewerContainer.addEventListener(AppEvent.DATA_OPT_LAYERS, sendOptlayers);
                ViewerContainer.addEventListener(AppEvent.MAP_LAYER_VISIBLE, changeLayerVisible);
            }

            protected override function partAdded(partName:String, instance:Object):void
            {
                super.partAdded(partName, instance);
                if (instance == map)
                {
                    var cssStyleDeclaration:CSSStyleDeclaration = styleManager.getStyleDeclaration("com.esri.ags.components.supportClasses.InfoWindow")
                    cssStyleDeclaration.setStyle("backgroundColor", getStyle('contentBackgroundColor'));
                    styleManager.setStyleDeclaration("com.esri.ags.components.supportClasses.InfoWindow", cssStyleDeclaration, true);
                }
            }

            private function setViewerVersion():void
            {
                var contextMenuText:String = getDefaultString("contextMenuText");
                var aboutText:String = getDefaultString("aboutText");
                var menuItem:ContextMenuItem = new ContextMenuItem(contextMenuText, true, true);
                menuItem.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, function(event:ContextMenuEvent):void
                {
                    // save normal labels
                    var buttonWidth:Number = Alert.buttonWidth;
                    var yesLabel:String = Alert.yesLabel;
                    var noLabel:String = Alert.noLabel;
                    // change labels
                    Alert.buttonWidth = 100;
                    Alert.yesLabel = getDefaultString("aboutLearnMoreBtn");
                    Alert.noLabel = getDefaultString("aboutCloseBtn");
                    Alert.show(aboutText, contextMenuText, Alert.YES | Alert.NO, null, function(event:CloseEvent):void
                    {
                        if (event.detail == Alert.YES)
                        {
                            navigateToURL(new URLRequest("http://help.arcgis.com/en/webapps/flexviewer/"));
                        }
                    }, StaticLayer_m_esriLogo, Alert.NO);
                    // restore labels to normal
                    Alert.buttonWidth = buttonWidth;
                    Alert.yesLabel = yesLabel;
                    Alert.noLabel = noLabel;
                });
                if (map.contextMenu)
                {
                    // call contextMenu dynamically so this will compile in AIR
                    if (map.contextMenu["customItems"] is Array)
                    {
                        (map.contextMenu["customItems"] as Array).push(menuItem);
                    }
                    else if (map.contextMenu["addItem"])
                    {
                        map.contextMenu["addItem"](menuItem);
                    }
                }
            }

            //config
            //TODO: Factory or builder pattern need to be used for extendability
            private function config(event:AppEvent):void
            {
                configData = event.data as ConfigData;

                ViewerContainer.dispatchEvent(new AppEvent(AppEvent.MAP_LOADED, map));

                var infoContainer:Canvas = new Canvas();
                infoContainer.setStyle("borderSkin", null);

                /* Adding these two lines removes the container that displays below the header controller in graphical theme
                   but increases CPU usage.
                   TODO: Need to convert see if this is needed. if yes, then could be replaced by Group

                   infoContainer.x = -100
                   infoContainer.y = -100
                 */
                infoContainer.percentWidth = 100;
                infoContainer.percentHeight = 100;
                infoContainer.horizontalScrollPolicy = "off";
                infoContainer.verticalScrollPolicy = "off";
                managerView.addElement(infoContainer);
                infoPopup = new InfoPopup();
                infoPopup.map = map;
                infoContainer.addChild(infoPopup);

                navTool = new NavigationTool();
                navTool.map = map;

                drawTool = new DrawTool();
                drawTool.map = map;
                drawTool.addEventListener(DrawEvent.DRAW_END, onDrawEnd);

                configMapAttributes();

                if (configData.webMapLayers)
                {
                    map.addEventListener(MapEvent.LAYER_ADD, layerloadComplete);
                    for each (var layer:Layer in configData.webMapLayers)
                    {
                        if (layer is FeatureLayer)
                        {
                            layer.addEventListener(FlexEvent.HIDE, featureLayer_hideHandler);
                        }
                        map.addLayer(layer);
                    }
                    optLayerTable = configData.opLayers;
                }
                else
                {
                    configBasemaps();
                    configOptLayers();
                    configReferenceBasemaps();
                }

                setViewerVersion();
            }

            private function configMapAttributes():void
            {
                var ref:SpatialReference;
                var iextent:Extent;

                for (var i:int = 0; i < configData.mapAttrs.length; i++)
                {
                    var id:String = configData.mapAttrs[i].id;

                    if (id == "full")
                    {
                        var ext:String = configData.mapAttrs[i].extent;
                        var extArray:Array = ext.split(" ");
                        var extent:Extent = new Extent(Number(extArray[0]), Number(extArray[1]), Number(extArray[2]), Number(extArray[3]));
                        fullExtent = extent;
                    }
                    else if (id == "initial")
                    {
                        var iext:String = configData.mapAttrs[i].extent;
                        var iextArray:Array = iext.split(" ");
                        iextent = new Extent(Number(iextArray[0]), Number(iextArray[1]), Number(iextArray[2]), Number(iextArray[3]));
                    }
                    else if (id == "center")
                    {
                        map.addEventListener(MapEvent.LOAD, map_loadHandler);
                    }
                    else if (id == "map")
                    {
                        var mapAttr:Object = configData.mapAttrs[i];
                        if (mapAttr.left || mapAttr.right || mapAttr.top || mapAttr.bottom)
                        {
                            this._mapManagerState = "decorated";
                            dispatchEvent(new Event(_mapManagerState));
                            invalidateSkinState();

                            if (mapAttr.left)
                            {
                                this.left = mapAttr.left;
                            }
                            if (mapAttr.right)
                            {
                                this.right = mapAttr.right;
                            }
                            if (mapAttr.top)
                            {
                                this.top = mapAttr.top;
                            }
                            if (mapAttr.bottom)
                            {
                                this.bottom = mapAttr.bottom;
                            }
                        }
                    }
                    else if (id == "spatialref")
                    {
                        var wkid:Number = configData.mapAttrs[i].wkid;
                        var wkt:String = configData.mapAttrs[i].wkt;

                        if (wkid || wkt)
                        {
                            ref = new SpatialReference(wkid, wkt);
                        }

                        configData.mapAttrs[i].refObj = ref;
                    }
                    else if (id == "zoomSlider")
                    {
                        map.zoomSliderVisible = configData.mapAttrs[i].zoomSliderVisible;
                    }
                    else if (id == "scaleBar")
                    {
                        map.scaleBarVisible = configData.mapAttrs[i].scaleBarVisible;
                    }
                    else if (id == "esriLogo")
                    {
                        map.logoVisible = configData.mapAttrs[i].esriLogoVisible;
                    }
                    else if (id == "openHandCursor")
                    {
                        map.openHandCursorVisible = configData.mapAttrs[i].openHandCursorVisible;
                    }
                    else if (id == "wrapAround180")
                    {
                        map.wrapAround180 = configData.mapAttrs[i].wrapAround180;
                    }
                    else if (id == "panEasingFactor")
                    {
                        map.panEasingFactor = configData.mapAttrs[i].panEasingFactor;
                    }
                    else if (id == "lods")
                    {
                        map.lods = configData.mapAttrs[i].lods;
                    }
                }

                if (fullExtent)
                {
                    fullExtent.spatialReference = ref;
                }
                if (iextent)
                {
                    iextent.spatialReference = ref;
                    map.extent = iextent;
                }
            }

            private function map_loadHandler(event:MapEvent):void
            {
                var center:String;
                var level:Number;
                var scale:Number;
                for (var i:int = 0; i < configData.mapAttrs.length; i++)
                {
                    var id:String = configData.mapAttrs[i].id;

                    if (id == "center")
                    {
                        center = configData.mapAttrs[i].center;
                    }
                    else if (id == "level")
                    {
                        level = parseInt(configData.mapAttrs[i].level);
                    }
                    else if (id == "scale")
                    {
                        scale = parseFloat(configData.mapAttrs[i].scale);
                    }
                }
                if (center)
                {
                    var centerXY:Array = center.split(" ");
                    if (centerXY.length == 2)
                    {
                        var centerPt:MapPoint = new MapPoint(centerXY[0], centerXY[1]);
                        map.centerAt(centerPt);
                        if (scale > 0)
                        {
                            map.scale = scale;
                        }
                        else if (level >= 0)
                        {
                            map.level = level;
                        }
                    }
                }
            }

            private var basemapLayers:Array = [];

            private function configBasemaps():void
            {
                var layers:Array = configData.basemaps;
                for (var i:uint = 0; i < layers.length; i++)
                {
                    if (!layers[i].reference)
                    {
                        basemapLayers.push(layers[i]);
                    }
                }

                if (basemapLayers.length > 0)
                {
                    loadNextBasemapLayer();
                }

                if (layers.length > 0)
                {
                    map.addEventListener(MapEvent.LAYER_ADD, layerloadComplete);
                }
            }

            private var basemapLayerIndex:int = 0;

            private function loadNextBasemapLayer():void
            {
                var basemapLayerObject:Object = basemapLayers[basemapLayerIndex];

                addLayerToMap(basemapLayerObject);
                configureLayerRenderer(basemapLayerObject, false);
            }

            private function configReferenceBasemaps():void
            {
                var layers:Array = configData.basemaps;
                for (var i:uint = 0; i < layers.length; i++)
                {
                    if (layers[i].reference)
                    {
                        addLayerToMap(layers[i]);
                    }
                }
            }

            private var optLayers:Array = [];

            private function configOptLayers():void
            {
                var layers:Array = configData.opLayers;
                if (layers && layers.length > 0)
                {
                    for (var i:uint = 0; i < layers.length; i++)
                    {
                        optLayers.push(layers[i]);
                    }
                }

                if (optLayers.length > 0)
                {
                    loadNextOptLayer();
                }
            }

            private var optLayerIndex:int = 0;

            private function loadNextOptLayer():void
            {
                var optLayerObject:Object = optLayers[optLayerIndex];

                // add layer to map and configure popups if any
                addLayerToMap(optLayerObject);
                configureLayerRenderer(optLayerObject, true);
            }

            private function addLayerToMap(layerObject:Object):void
            {
                const alpha:Number = Number(layerObject.alpha);
                const autoRefresh:Number = Number(layerObject.autoRefresh);
                const bandIds:String = layerObject.bandIds;
                const bingMapKey:String = layerObject.key;
                const culture:String = layerObject.culture;
                const definitionExpression:String = layerObject.definitionExpression;
                const displayLevels:String = layerObject.displayLevels;
                const imageFormat:String = layerObject.imageFormat;
                const label:String = layerObject.label;
                const mode:String = layerObject.mode;
                const noData:Number = Number(layerObject.noData);
                const password:String = layerObject.password;
                const proxyUrl:String = configData.proxyUrl;
                const serviceHost:String = layerObject.serviceHost;
                const serviceName:String = layerObject.serviceName;
                const skipGetCapabilities:String = layerObject.skipGetCapabilities;
                const style:String = layerObject.style;
                const token:String = layerObject.token;
                const type:String = layerObject.type;
                const url:String = layerObject.url;
                const useAMF:String = layerObject.useAMF;
                const useMapTime:Boolean = layerObject.useMapTime;
                const useProxy:Boolean = layerObject.useProxy;
                const username:String = layerObject.username;
                const version:String = layerObject.version;
                const visible:Boolean = layerObject.visible;
                const visibleLayers:String = layerObject.visibleLayers;
                const wkid:Number = layerObject.wkid;

                var i:int;
                switch (type.toLowerCase())
                {
					case "googleannotation":
					{
						var tiledLayer:ArcGISTiledMapServiceLayer;
						tiledLayer= new GoogleAnnotation();
						tiledLayer.alpha = alpha;
						tiledLayer.id = label;
						tiledLayer.name = label;
						tiledLayer.token = token;
						tiledLayer.visible = visible;
						if (displayLevels)
						{
							tiledLayer.displayLevels = displayLevels.split(",");
							for (i = 0; i < tiledLayer.displayLevels.length; i++)
							{
								tiledLayer.displayLevels[i] = Number(tiledLayer.displayLevels[i]); // convert to Numbers
							}
						}
						if (proxyUrl && useProxy)
						{
							tiledLayer.proxyURL = proxyUrl;
						}
						layerObject.layer = tiledLayer;
						map.addLayer(tiledLayer);
						break;
					}
					case "googlemap":
					{
						var tiledLayer:ArcGISTiledMapServiceLayer;
						tiledLayer= new GoogleMapLayer(GoogleMapLayer.DIXINGMap);
						tiledLayer.alpha = alpha;
						tiledLayer.id = label;
						tiledLayer.name = label;
						tiledLayer.token = token;
						tiledLayer.visible = visible;
						if (displayLevels)
						{
							tiledLayer.displayLevels = displayLevels.split(",");
							for (i = 0; i < tiledLayer.displayLevels.length; i++)
							{
								tiledLayer.displayLevels[i] = Number(tiledLayer.displayLevels[i]); // convert to Numbers
							}
						}
						if (proxyUrl && useProxy)
						{
							tiledLayer.proxyURL = proxyUrl;
						}
						layerObject.layer = tiledLayer;
						map.addLayer(tiledLayer);
						break;
					}
					case "googlemap_aerial":
					{
						var tiledLayer:ArcGISTiledMapServiceLayer;
						tiledLayer= new GoogleAerial();
						tiledLayer.alpha = alpha;
						tiledLayer.id = label;
						tiledLayer.name = label;
						tiledLayer.token = token;
						tiledLayer.visible = visible;
						if (displayLevels)
						{
							tiledLayer.displayLevels = displayLevels.split(",");
							for (i = 0; i < tiledLayer.displayLevels.length; i++)
							{
								tiledLayer.displayLevels[i] = Number(tiledLayer.displayLevels[i]); // convert to Numbers
							}
						}
						if (proxyUrl && useProxy)
						{
							tiledLayer.proxyURL = proxyUrl;
						}
						layerObject.layer = tiledLayer;
						map.addLayer(tiledLayer);
						break;
					}
					case "customtiled":
					{
						var tiledLayer:ArcGISTiledMapServiceLayer;
						tiledLayer= new CustomTiledLayer(url);
						tiledLayer.alpha = alpha;
						tiledLayer.id = label;
						tiledLayer.name = label;
						tiledLayer.token = token;
						tiledLayer.visible = visible;
						if (displayLevels)
						{
							tiledLayer.displayLevels = displayLevels.split(",");
							for (i = 0; i < tiledLayer.displayLevels.length; i++)
							{
								tiledLayer.displayLevels[i] = Number(tiledLayer.displayLevels[i]); // convert to Numbers
							}
						}
						if (proxyUrl && useProxy)
						{
							tiledLayer.proxyURL = proxyUrl;
						}
						layerObject.layer = tiledLayer;
						map.addLayer(tiledLayer);
						break;
					}
					case "googletiledmapservicelayer":
					{
						var tiledLayer:ArcGISTiledMapServiceLayer;
						tiledLayer= new GoogleTiledMapServiceLayer(url);
						tiledLayer.alpha = alpha;
						tiledLayer.id = label;
						tiledLayer.name = label;
						tiledLayer.token = token;
						tiledLayer.visible = visible;
						if (displayLevels)
						{
							tiledLayer.displayLevels = displayLevels.split(",");
							for (i = 0; i < tiledLayer.displayLevels.length; i++)
							{
								tiledLayer.displayLevels[i] = Number(tiledLayer.displayLevels[i]); // convert to Numbers
							}
						}
						if (proxyUrl && useProxy)
						{
							tiledLayer.proxyURL = proxyUrl;
						}
						layerObject.layer = tiledLayer;
						map.addLayer(tiledLayer);
						break;
					}
                    case "tiled":
                    {
						var tiledLayer:ArcGISTiledMapServiceLayer;
						tiledLayer= new ArcGISTiledMapServiceLayer(url);
                        tiledLayer.alpha = alpha;
                        tiledLayer.id = label;
                        tiledLayer.name = label;
                        tiledLayer.token = token;
                        tiledLayer.visible = visible;
                        if (displayLevels)
                        {
                            tiledLayer.displayLevels = displayLevels.split(",");
                            for (i = 0; i < tiledLayer.displayLevels.length; i++)
                            {
                                tiledLayer.displayLevels[i] = Number(tiledLayer.displayLevels[i]); // convert to Numbers
                            }
                        }
                        if (proxyUrl && useProxy)
                        {
                            tiledLayer.proxyURL = proxyUrl;
                        }
                        layerObject.layer = tiledLayer;
                        map.addLayer(tiledLayer);
                        break;
                    }
                    case "dynamic":
                    {
                        var dynLayer:ArcGISDynamicMapServiceLayer = new ArcGISDynamicMapServiceLayer(url);
                        dynLayer.alpha = alpha;
                        dynLayer.id = label;
                        dynLayer.name = label;
                        dynLayer.token = token;
                        dynLayer.visible = visible;
                        dynLayer.useMapTime = useMapTime;
                        if (autoRefresh > 0)
                        {
                            setInterval(dynLayer.refresh, autoRefresh * 1000);
                        }
                        if (imageFormat)
                        {
                            dynLayer.imageFormat = imageFormat;
                        }
                        if (visibleLayers)
                        {
                            var vizLayers:Array = visibleLayers.split(",");
                            for (i = 0; i < vizLayers.length; i++)
                            {
                                vizLayers[i] = Number(vizLayers[i]); // convert to Numbers
                            }
                            dynLayer.visibleLayers = new ArrayCollection(vizLayers);
                        }
                        if (proxyUrl && useProxy)
                        {
                            dynLayer.proxyURL = proxyUrl;
                        }
                        layerObject.layer = dynLayer;
                        map.addLayer(dynLayer);
                        break;
                    }
					case "dynamicmapserver":
					{
						var dynLayer:ArcGISDynamicMapServiceLayer = new ArcGISDynamicMapServiceLayer(url);
						dynLayer.alpha = alpha;
						dynLayer.id = label;
						dynLayer.name = label;
						dynLayer.token = token;
						dynLayer.visible = visible;
						dynLayer.useMapTime = useMapTime;
						if (autoRefresh > 0)
						{
							setInterval(dynLayer.refresh, autoRefresh * 1000);
						}
						if (imageFormat)
						{
							dynLayer.imageFormat = imageFormat;
						}
						var vizLayers:Array = [0,1];
						dynLayer.visibleLayers = new ArrayCollection(vizLayers);
						if (proxyUrl && useProxy)
						{
							dynLayer.proxyURL = proxyUrl;
						}
						layerObject.layer = dynLayer;
						map.addLayer(dynLayer);
						break;
					}
                    case "feature":
                    {
                        var featureLayer:FeatureLayer = new FeatureLayer(url);
                        featureLayer.addEventListener(FlexEvent.HIDE, featureLayer_hideHandler);
                        featureLayer.alpha = alpha;
                        featureLayer.id = label;
                        featureLayer.name = label;
                        featureLayer.outFields = [ '*' ]; // TODO: be smarter
                        featureLayer.token = token;
                        featureLayer.visible = visible;
                        featureLayer.useMapTime = useMapTime;
                        if (useAMF)
                        {
                            featureLayer.useAMF = (useAMF == "true");
                        }
                        if (mode)
                        {
                            featureLayer.mode = mode;
                        }
                        if (definitionExpression)
                        {
                            featureLayer.definitionExpression = definitionExpression;
                        }
                        if (proxyUrl && useProxy)
                        {
                            featureLayer.proxyURL = proxyUrl;
                        }
                        layerObject.layer = featureLayer;
                        map.addLayer(featureLayer);
                        break;
                    }
                    case "bing":
                    {
                        var veTiledLayer:VETiledLayer = new VETiledLayer();
                        veTiledLayer.id = label;
                        veTiledLayer.name = label;
                        veTiledLayer.key = bingMapKey;
                        veTiledLayer.visible = visible;
                        veTiledLayer.alpha = alpha;
                        if (style)
                        {
                            veTiledLayer.mapStyle = style;
                        }
                        if (culture)
                        {
                            veTiledLayer.culture = culture;
                        }
                        if (displayLevels)
                        {
                            veTiledLayer.displayLevels = displayLevels.split(",");
                            for (i = 0; i < veTiledLayer.displayLevels.length; i++)
                            {
                                veTiledLayer.displayLevels[i] = Number(veTiledLayer.displayLevels[i]); // convert to Numbers
                            }
                        }
                        layerObject.layer = veTiledLayer;
                        map.addLayer(veTiledLayer);
                        break;
                    }
                    case "image":
                    {
                        var imgLayer:ArcGISImageServiceLayer = new ArcGISImageServiceLayer(url);
                        imgLayer.id = label;
                        imgLayer.name = label;
                        imgLayer.alpha = alpha;
                        imgLayer.token = token;
                        imgLayer.visible = visible;
                        imgLayer.noData = noData;
                        imgLayer.useMapTime = useMapTime;
                        if (imageFormat)
                        {
                            imgLayer.imageFormat = imageFormat;
                        }
                        if (bandIds)
                        {
                            imgLayer.bandIds = bandIds.split(",");
                            for (i = 0; i < imgLayer.bandIds.length; i++)
                            {
                                imgLayer.bandIds[i] = Number(imgLayer.bandIds[i]); // convert to Numbers
                            }
                        }
                        if (proxyUrl && useProxy)
                        {
                            imgLayer.proxyURL = proxyUrl;
                        }
                        layerObject.layer = imgLayer;
                        map.addLayer(imgLayer);
                        break;
                    }
                    case "arcims":
                    {
                        var arcimsLayer:ArcIMSMapServiceLayer = new ArcIMSMapServiceLayer();
                        arcimsLayer.alpha = alpha;
                        arcimsLayer.id = label;
                        arcimsLayer.name = label;
                        arcimsLayer.visible = visible;
                        arcimsLayer.serviceHost = serviceHost;
                        arcimsLayer.serviceName = serviceName;
                        if (autoRefresh > 0)
                        {
                            setInterval(arcimsLayer.refresh, autoRefresh * 1000);
                        }
                        if (imageFormat)
                        {
                            arcimsLayer.imageFormat = imageFormat;
                        }
                        if (visibleLayers)
                        {
                            var visLayers:Array = visibleLayers.split(",");
                            arcimsLayer.visibleLayers = new ArrayCollection(visLayers);
                        }
                        if (proxyUrl && useProxy)
                        {
                            arcimsLayer.proxyURL = proxyUrl;
                        }
                        if (username && password)
                        {
                            arcimsLayer.username = username;
                            arcimsLayer.password = password;
                        }
                        layerObject.layer = arcimsLayer;
                        map.addLayer(arcimsLayer);
                        break;
                    }
                    case "wms":
                    {
                        var wmsLayer:WMSLayer = new WMSLayer(url);
                        wmsLayer.alpha = alpha;
                        wmsLayer.id = label;
                        wmsLayer.name = label;
                        wmsLayer.visible = visible;
                        if (wkid)
                        {
                            wmsLayer.spatialReference = new SpatialReference(wkid);
                        }
                        if (autoRefresh > 0)
                        {
                            setInterval(wmsLayer.refresh, autoRefresh * 1000);
                        }
                        if (imageFormat)
                        {
                            wmsLayer.imageFormat = imageFormat;
                        }
                        if (visibleLayers)
                        {
                            var wmsVisLayers:Array = visibleLayers.split(",");
                            wmsLayer.visibleLayers = new ArrayList(wmsVisLayers);
                        }
                        if (proxyUrl && useProxy)
                        {
                            wmsLayer.proxyURL = proxyUrl;
                        }
                        if (skipGetCapabilities)
                        {
                            wmsLayer.skipGetCapabilities = skipGetCapabilities == "true";
                        }
                        if (username && password)
                        {
                            wmsLayer.username = username;
                            wmsLayer.password = password;
                        }
                        if (version)
                        {
                            wmsLayer.version = version;
                        }
                        layerObject.layer = wmsLayer;
                        map.addLayer(wmsLayer);
                        break;
                    }
                    case "osm":
                    {
                        var osmLayer:OpenStreetMapLayer = new OpenStreetMapLayer();
                        osmLayer.alpha = alpha;
                        osmLayer.id = label;
                        osmLayer.name = label;
                        osmLayer.visible = visible;
                        layerObject.layer = osmLayer;
                        map.addLayer(osmLayer);
                        break;
                    }
                    default:
                    {
                        Alert.show(StringUtil.substitute(getDefaultString('incorrectLayerTypeText'), "'" + type + "'"));
                        break;
                    }
                }
            }

            private function featureLayer_hideHandler(event:FlexEvent):void
            {
                const featureLayer:FeatureLayer = event.target as FeatureLayer;
                const graphic:Graphic = map.infoWindow.contentOwner as Graphic;
                if (map.infoWindow.visible && graphic && graphic.graphicsLayer === featureLayer)
                {
                    map.infoWindow.hide();
                }
            }

            private function configureLayerRenderer(layerObject:Object, isOptLayer:Boolean):void
            {
                if (layerObject.layer is ArcGISDynamicMapServiceLayer || layerObject.layer is ArcGISTiledMapServiceLayer)
                {
                    // look at the sublayers
                    if ((layerObject.subLayers as Array).length > 0)
                    {
                        var arrLayerInfoWindowRenderer:Array = [];

                        var i:int;
                        var arrSubLayerPopUp:Array = [];
                        var arrSubLayerInfoWinWidget:Array = [];
                        var countPopUpOrInfoWinWidget:int = 0;
                        for (i = 0; i < layerObject.subLayers.length; i++)
                        {
                            if (layerObject.subLayers[i].popUpConfig)
                            {
                                countPopUpOrInfoWinWidget++;
                                arrSubLayerPopUp.push({ layer: layerObject.layer, sublayer: layerObject.subLayers[i], popUpConfig: layerObject.subLayers[i].popUpConfig });
                            }
                            else if (layerObject.subLayers[i].infoConfig)
                            {
                                countPopUpOrInfoWinWidget++;
                                arrSubLayerInfoWinWidget.push({ layer: layerObject.layer, sublayer: layerObject.subLayers[i], infoConfig: layerObject.subLayers[i].infoConfig, info: layerObject.sublayers[i].info });
                            }
                        }
                        // popups for sublayers
                        if (arrSubLayerPopUp.length > 0)
                        {
                            configurePopUps(isOptLayer, arrSubLayerPopUp, true, arrLayerInfoWindowRenderer);
                        }

                        // simple info win widget for sublayers
                        for (i = 0; i < arrSubLayerInfoWinWidget.length; i++)
                        {
                            var layerInfoWindowRenderer:LayerInfoWindowRenderer = new LayerInfoWindowRenderer;
                            layerInfoWindowRenderer.layerId = arrSubLayerInfoWinWidget[i].sublayer.id;

                            var sublayerData:Object = {
                                    id: arrSubLayerInfoWinWidget[i].id,
                                    url: arrSubLayerInfoWinWidget[i].info,
                                    config: arrSubLayerInfoWinWidget[i].infoConfig,
                                    layerInfoWindowRenderer: layerInfoWindowRenderer
                                };
                            ViewerContainer.dispatchEvent(new AppEvent(AppEvent.DATA_CREATE_INFOWIDGET, sublayerData, subLayerInfoReady));
                        }

                        function subLayerInfoReady(event:AppEvent):void
                        {
                            var infoTemplate:IInfowindowTemplate = event.data.infoWidget;
                            var biWidget:IBaseWidget = infoTemplate as IBaseWidget;
                            var infoConfigXML:XML = biWidget.configXML;

                            var infoRender:ClassFactory = new ClassFactory(infoTemplate.infoClass);
                            infoRender.properties = { infoConfig: infoConfigXML, map: map };

                            event.data.layerInfoWindowRenderer.infoWindowRenderer = infoRender;
                            arrLayerInfoWindowRenderer.push(event.data.layerInfoWindowRenderer);

                            if (arrLayerInfoWindowRenderer.length == countPopUpOrInfoWinWidget)
                            {
                                layerObject.layer.layerInfoWindowRenderers = arrLayerInfoWindowRenderer;
                                loadNextOptOrBasemapLayer(isOptLayer);
                            }
                        }
                    }
                    else
                    {
                        loadNextOptOrBasemapLayer(isOptLayer);
                    }
                }
                else if (layerObject.popUpConfig)
                {
                    configurePopUps(isOptLayer, [{ layer: layerObject.layer, popUpConfig: layerObject.popUpConfig }], false);
                }
                else if (layerObject.infoUrl)
                {
                    var data:Object = {
                            id: layerObject.label,
                            url: layerObject.infoUrl,
                            config: layerObject.infoConfig,
                            isOptLayer: isOptLayer
                        };
                    ViewerContainer.dispatchEvent(new AppEvent(AppEvent.DATA_CREATE_INFOWIDGET, data, infoReady));
                }
                else
                {
                    loadNextOptOrBasemapLayer(isOptLayer);
                }

                function configurePopUps(isOptLayer:Boolean, arrLayerPopUp:Array, isSublayer:Boolean, arrLayerInfoWindowRenderer:Array = null):void
                {
                    var popUpCount:int = 0;
                    var arrPopUp:Array = [];
                    for (i = 0; i < arrLayerPopUp.length; i++)
                    {
                        if (isSublayer)
                        {
                            var layerInfoWindowRenderer:LayerInfoWindowRenderer = new LayerInfoWindowRenderer;
                            layerInfoWindowRenderer.layerId = arrLayerPopUp[i].sublayer.id;
                        }

                        var popUpConfigUrl:String = arrLayerPopUp[i].popUpConfig;
                        var configService:HTTPService = new HTTPService();
                        configService.url = popUpConfigUrl;
                        configService.resultFormat = "e4x";
                        var asyncToken:AsyncToken = configService.send();
                        asyncToken.addResponder(new AsyncResponder(configResult, configFault, { layer: arrLayerPopUp[i].layer, layerInfoWindowRenderer: isSublayer ? layerInfoWindowRenderer : null }));
                    }

                    //config result
                    function configResult(event:ResultEvent, token:Object = null):void
                    {
                        popUpCount++;
                        arrPopUp.push({ popUpConfigXML: event.result as XML, layer: token.layer, isSublayer: isSublayer, layerInfoWindowRenderer: token.layerInfoWindowRenderer });
                        if (popUpCount == arrLayerPopUp.length)
                        {
                            createPopUpRenderer(isOptLayer, arrPopUp, arrLayerInfoWindowRenderer);
                        }
                    }

                    //config fault
                    function configFault(event:FaultEvent, token:Object = null):void
                    {
                        // happens if for example the popup config file missing or have crossdomain problem
                        var sInfo:String = "";

                        // Missing file
                        if (event.fault.rootCause is IOErrorEvent)
                        {
                            var ioe:IOErrorEvent = event.fault.rootCause as IOErrorEvent;
                            if (ioe.text.indexOf("2032: Stream Error. URL:") > -1)
                            {
                                sInfo += StringUtil.substitute(getDefaultString('missingConfigFile'), ioe.text.substring(32)) + "\n\n";
                            }
                            else
                            {
                                // some other IOError
                                sInfo += event.fault.rootCause + "\n\n";
                            }
                        }

                        // config file with crossdomain issue
                        if (event.fault.rootCause is SecurityErrorEvent)
                        {
                            var sec:SecurityErrorEvent = event.fault.rootCause as SecurityErrorEvent;
                            if (sec.text.indexOf("Error #2048: ") > -1)
                            {
                                sInfo += StringUtil.substitute(getDefaultString('configFileCrossDomain'), "\n", sec.text) + "\n\n";
                            }
                            else
                            {
                                // some other Security error
                                sInfo += event.fault.rootCause + "\n\n";
                            }
                        }

                        if (event.statusCode) // e.g. 404 - Not Found - http://en.wikipedia.org/wiki/List_of_HTTP_status_codes
                        {
                            sInfo += StringUtil.substitute(getDefaultString('httpResponseStatus'), event.statusCode) + "\n\n";
                        }

                        // sInfo += "Event Target: " + event.target + "\n\n";
                        // sInfo += "Event Type: " + event.type + "\n\n";
                        sInfo += StringUtil.substitute(getDefaultString('faultCode'), event.fault.faultCode) + "\n\n";
                        sInfo += StringUtil.substitute(getDefaultString('faultInfo'), event.fault.faultString) + "\n\n";
                        sInfo += StringUtil.substitute(getDefaultString('faultDetail'), event.fault.faultDetail);

                        showError(sInfo);

                        popUpCount++;
                        if (popUpCount == arrLayerPopUp.length)
                        {
                            createPopUpRenderer(isOptLayer, arrPopUp, arrLayerInfoWindowRenderer);
                        }
                    }
                }

                function createPopUpRenderer(isOptLayer:Boolean, arr:Array, arrLayerInfoWindowRenderer:Array = null):void
                {
                    for (var p:int = 0; p < arr.length; p++)
                    {
                        var popUpConfigXML:XML = arr[p].popUpConfigXML;
                        try
                        {
                            var popUpInfo:PopUpInfo = new PopUpInfo();
                            var i:int;
                            if (popUpConfigXML.fields[0])
                            {
                                var fields:XMLList = popUpConfigXML.fields[0].field;

                                var pFieldInfos:Array = new Array();
                                for (i = 0; i < fields.length(); i++)
                                {
                                    var pFieldInfo:PopUpFieldInfo = new PopUpFieldInfo();
                                    pFieldInfo.fieldName = fields[i].@name;
                                    if (fields[i].@alias[0])
                                    {
                                        pFieldInfo.label = fields[i].@alias;
                                    }
                                    pFieldInfo.visible = fields[i].@visible == "true";

                                    pFieldInfo.format = new PopUpFieldFormat();
                                    if (fields[i].format.@dateformat[0])
                                    {
                                        pFieldInfo.format.dateFormat = fields[i].format.@dateformat;
                                    }
                                    if (fields[i].format.@precision[0])
                                    {
                                        pFieldInfo.format.precision = fields[i].format.@precision;
                                    }
                                    if (fields[i].format.@usethousandsseparator[0])
                                    {
                                        pFieldInfo.format.useThousandsSeparator = fields[i].format.@usethousandsseparator == "true";
                                    }
                                    pFieldInfos.push(pFieldInfo);
                                }
                                popUpInfo.popUpFieldInfos = pFieldInfos;
                            }
                            if (popUpConfigXML.medias[0])
                            {
                                var medias:XMLList = popUpConfigXML.medias[0].media;

                                var pMediaInfos:Array = new Array();
                                for (i = 0; i < medias.length(); i++)
                                {
                                    var pMediaInfo:PopUpMediaInfo = new PopUpMediaInfo();
                                    pMediaInfo.caption = medias[i].@caption;
                                    pMediaInfo.title = medias[i].@title;
                                    pMediaInfo.type = medias[i].@type;
                                    pMediaInfo.imageLinkURL = medias[i].@imagelink;
                                    pMediaInfo.imageSourceURL = medias[i].@imagesource;
                                    
                                    if (medias[i].@chartfields[0])
                                    {
                                        var chartFields:Array = medias[i].@chartfields.split(",");
                                        pMediaInfo.chartFields = chartFields;
                                    }

                                    pMediaInfos.push(pMediaInfo);
                                }
                                popUpInfo.popUpMediaInfos = pMediaInfos;
                            }
                            popUpInfo.title = popUpConfigXML.title;
                            popUpInfo.description = popUpConfigXML.description;
                            if (popUpConfigXML.showattachments[0])
                            {
                                popUpInfo.showAttachments = popUpConfigXML.showattachments == "true";
                            }

                            var popUpRenderer:ClassFactory = new ClassFactory(PopUpRenderer);
                            popUpRenderer.properties = { popUpInfo: popUpInfo };

                            if (arr[p].isSublayer)
                            {
                                arr[p].layerInfoWindowRenderer.infoWindowRenderer = popUpRenderer;
                                arrLayerInfoWindowRenderer.push(arr[p].layerInfoWindowRenderer);
                                if (p == arr.length - 1)
                                {
                                    arr[p].layer.layerInfoWindowRenderers = arrLayerInfoWindowRenderer;
                                }
                            }
                            else
                            {
                                arr[p].layer.infoWindowRenderer = popUpRenderer;
                            }
                        }
                        catch (error:Error)
                        {
                            showError(StringUtil.substitute(getDefaultString("parseConfigError"), error.message));
                        }
                    }
                    loadNextOptOrBasemapLayer(isOptLayer);
                }

                function showError(errorMessage:String):void
                {
                    ViewerContainer.dispatchEvent(new AppEvent(AppEvent.APP_ERROR, errorMessage));
                }
            }

            private var infoTemplate:IInfowindowTemplate;
            private var infoRender:ClassFactory;

            private function infoReady(event:AppEvent):void
            {
                var id:String = event.data.id as String;
                var isOperationLayer:Boolean = event.data.isOptLayer;
                var label:String = isOperationLayer ? optLayers[optLayerIndex].label : basemapLayers[basemapLayerIndex].label;
                if (id == label)
                {
                    infoTemplate = event.data.infoWidget;
                    var biWidget:IBaseWidget = infoTemplate as IBaseWidget;
                    var infoConfigXML:XML = biWidget.configXML;
                    infoRender = new ClassFactory(infoTemplate.infoClass);
                    infoRender.properties = { infoConfig: infoConfigXML, map: map };

                    if (isOperationLayer)
                    {
                        optLayers[optLayerIndex].layer.infoWindowRenderer = infoRender;
                    }
                    else
                    {
                        basemapLayers[basemapLayerIndex].layer.infoWindowRenderer = infoRender;
                    }
                    loadNextOptOrBasemapLayer(isOperationLayer);
                }
            }

            private function loadNextOptOrBasemapLayer(isOptLayer:Boolean):void
            {
                if (isOptLayer)
                {
                    optLayerTable.push(optLayers[optLayerIndex]);
                    optLayerIndex++;
                    if (optLayerIndex < optLayers.length)
                    {
                        loadNextOptLayer();
                    }
                }
                else
                {
                    basemapLayerIndex++;
                    if (basemapLayerIndex < basemapLayers.length)
                    {
                        loadNextBasemapLayer();
                    }
                }
            }

            private function sendOptlayers(event:AppEvent):void
            {
                var callback:Function = event.callback as Function;
                callback(new AppEvent(AppEvent.DATA_OPT_LAYERS, this.optLayerTable));
            }

            private function layerloadComplete(event:MapEvent):void
            {
                ViewerContainer.dispatchEvent(new AppEvent(AppEvent.LAYER_LOADED));
            }

            override protected function getCurrentSkinState():String
            {
                return _mapManagerState;
            }

            //nav tool clicked
            private function changeNavigationbyWidget(event:AppEvent):void
            {
                navigationTool = event.data ? event.data.tool : null;
                navigationStatus = event.data ? event.data.status : null;

                changeNavigation(navigationTool, navigationStatus);
            }

            private function changeNavigationbyMenu(event:AppEvent):void
            {
                navigationTool = event.data ? event.data.tool : null;
                navigationStatus = event.data ? event.data.status : null;

                changeNavigation(navigationTool, navigationStatus);
            }

            private function changeNavigation(tool:String, status:String):void
            {
                map.removeEventListener(MouseEvent.ROLL_OVER, map_rollOverHandler);
                map.removeEventListener(MouseEvent.ROLL_OUT, map_rollOutHandler);
                if (tool)
                {
                    switch (tool)
                    {
                        case NavigationTool.ZOOM_IN:
                        {
                            // custom cursor
                            map.addEventListener(MouseEvent.ROLL_OVER, map_rollOverHandler);
                            map.addEventListener(MouseEvent.ROLL_OUT, map_rollOutHandler);

                            drawTool.deactivate();
                            navTool.deactivate();
                            navTool.activate(tool);
                            ViewerContainer.setStatus(status);
                            break;
                        }
                        case NavigationTool.ZOOM_OUT:
                        {
                            // custom cursor
                            map.addEventListener(MouseEvent.ROLL_OVER, map_rollOverHandler);
                            map.addEventListener(MouseEvent.ROLL_OUT, map_rollOutHandler);

                            drawTool.deactivate();
                            navTool.deactivate();
                            navTool.activate(tool);
                            ViewerContainer.setStatus(status);
                            break;
                        }
                        case ViewerContainer.NAVIGATION_ZOOM_FULL:
                        {
                            if (fullExtent)
                            {
                                map.extent = fullExtent
                            }
                            else
                            {
                                map.zoomToInitialExtent(); // use map.zoomToInitialExtent() as NavigationTool.zoomToFullExtent() is deprecated
                            }
                            ViewerContainer.setStatus(null);
                            break;
                        }
                        case ViewerContainer.NAVIGATION_ZOOM_PREVIOUS:
                        {
                            navTool.zoomToPrevExtent();
                            ViewerContainer.setStatus(null);
                            break;
                        }
                        case ViewerContainer.NAVIGATION_ZOOM_NEXT:
                        {
                            navTool.zoomToNextExtent();
                            ViewerContainer.setStatus(null);
                            break;
                        }
                        case NavigationTool.PAN:
                        {
                            drawTool.deactivate();
                            navTool.activate(tool);
                            navTool.deactivate();
                            ViewerContainer.setStatus(status);
                            break;
                        }
                        default:
                        {
                            drawTool.deactivate();
                            navTool.activate(NavigationTool.PAN);
                            navTool.deactivate();
                            ViewerContainer.setStatus(defaultstatus);
                            break;
                        }
                    }
                }
            }

            private function map_rollOverHandler(event:MouseEvent):void
            {
                map.cursorManager.setCursor(_crossCursor, CursorManagerPriority.MEDIUM, -8, -8);
            }

            private function map_rollOutHandler(event:MouseEvent):void
            {
                map.cursorManager.removeAllCursors();
            }

            //draw tool clicked
            private function enableMapAction(event:AppEvent):void
            {
                var data:Object = event.data;
                var tool:String = data.tool;
                var status:String = data.status;
                var symbol:Symbol = data.symbol;

                if (tool)
                {
                    // make sure there is no custom cursor
                    map.cursorManager.removeAllCursors();
                    map.removeEventListener(MouseEvent.ROLL_OVER, map_rollOverHandler);
                    map.removeEventListener(MouseEvent.ROLL_OUT, map_rollOutHandler);

                    drawEndFunction = data.handler;
                    navTool.deactivate();
                    drawTool.activate(tool);
                    // reset symbology
                    drawTool.markerSymbol = new SimpleMarkerSymbol;
                    drawTool.lineSymbol = new SimpleLineSymbol;
                    drawTool.fillSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, 0, 0.5, new SimpleLineSymbol);
                    if (symbol)
                    {
                        if (symbol is TextSymbol || symbol is SimpleMarkerSymbol)
                        {
                            drawTool.markerSymbol = symbol;
                        }
                        else if (symbol is SimpleLineSymbol)
                        {
                            drawTool.lineSymbol = symbol;
                        }
                        else if (symbol is SimpleFillSymbol)
                        {
                            drawTool.fillSymbol = symbol;
                        }
                    }

                    //map.zoomSliderVisible = true;
                    ViewerContainer.setStatus(status);
                }
                else
                {
                    drawTool.deactivate();
                    restoreNavigation();
                }
            }

            private function onDrawEnd(event:DrawEvent):void
            {
                restoreNavigation();
                drawEndFunction(event);
            }

            private function restoreNavigation():void
            {
                if (navigationTool == NavigationTool.ZOOM_IN || navigationTool == NavigationTool.ZOOM_OUT || navigationTool == NavigationTool.PAN)
                {
                    if (!(navigationTool == NavigationTool.PAN))
                    {
                        map.cursorManager.setCursor(_crossCursor, CursorManagerPriority.MEDIUM, -8, -8);
                    }
                    changeNavigation(navigationTool, navigationStatus);
                }
            }

            private function changeLayerVisible(event:AppEvent):void
            {
                var lyrData:Object = event.data;

                lyrData.layer.visible = lyrData.visible;

                //ViewerContainer.publish(AppEvent.LAYER_VISIBLE_CHANGED, event.data);
            }

            //basemap menu clicked
            private function basemapMenuClicked(event:AppEvent):void
            {
                var id:String = event.data as String;
                var configBasemaps:Array = configData.basemaps;

                if (id)
                {
                    var selectedLabel:String;
                    for (var i:uint = 0; i < configBasemaps.length; i++)
                    {
                        if (configBasemaps[i].id == id)
                        {
                            selectedLabel = configBasemaps[i].label;
                            break;
                        }
                    }
                    if (selectedLabel)
                    {
                        // turn on the selected basemap layers (more than one layer can have the same label)
                        var layers:ArrayCollection = map.layers as ArrayCollection;
                        for (i = 0; i < configBasemaps.length; i++)
                        {
                            var basemapLabel:String = configBasemaps[i].label;
                            for each (var layer:Layer in layers)
                            {
                                if (layer.id == basemapLabel)
                                {
                                    if (layer.id == selectedLabel)
                                    {
                                        layer.visible = true;
                                    }
                                    else
                                    {
                                        layer.visible = false;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            private function widgetShowInfo(event:AppEvent):void
            {
                infoPopup.infoData = event.data;
            }

            private function resizeMap(event:AppEvent):void
            {
                var size:Object = event.data;

                mapLeft = size.left;
                mapRight = size.right;
                mapTop = size.top;
                mapBottom = size.bottom;

                this._mapManagerState = "resized";

                dispatchEvent(new Event(_mapManagerState));
                invalidateSkinState();
            }

            private function getDefaultString(token:String):String
            {
                return resourceManager.getString("ViewerStrings", token);
            }
        ]]>
    </fx:Script>
</s:SkinnableContainer>
